<!DOCTYPE html>
<html>
<head>
    <title>10K clash royale</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; }
        canvas { display: block; }
    </style>
</head>
<body>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

/*back*/
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xaaaaaa);

const camera = new THREE.PerspectiveCamera(
    window.innerWidth < 600 ? 85 : 75, 
    window.innerWidth / window.innerHeight,
    0.1, 
    1000
);
camera.position.set(0, 5, 10);
camera.lookAt(0, 4, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/*orbit*/
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.minDistance = 6;
controls.maxDistance = 20;
controls.maxPolarAngle = Math.PI / 1.8;

/*texture_pack*/
const loader = new THREE.TextureLoader();
const stoneTexture = loader.load("https://threejs.org/examples/textures/brick_diffuse.jpg");
stoneTexture.wrapS = THREE.RepeatWrapping;
stoneTexture.wrapT = THREE.RepeatWrapping;
stoneTexture.repeat.set(4, 3);

/*more_texture*/
const stoneMaterial = new THREE.MeshStandardMaterial({
    map: stoneTexture,
    color: 0x999999
});

const blueMaterial = new THREE.MeshStandardMaterial({
    color: 0x228BEE,
    metalness: 0.8,
    roughness: 0.2
});

const goldMaterial = new THREE.MeshStandardMaterial({
    color: 0xFFD700,
    metalness: 1.0,
    roughness: 0.3,
    emissive: 0x442200,
    emissiveIntensity: 0.3
});

/*ckae*/
const towerHeight = 6;
const blueRingHeight = 1;
const goldTopHeight = 1.5;

/*tow*/
const towerGeometry = new THREE.CylinderGeometry(3.5, 3.5, towerHeight, 32);
const towerMesh = new THREE.Mesh(towerGeometry, stoneMaterial);
towerMesh.position.y = towerHeight / 2;
scene.add(towerMesh);

/*crown_blue*/
const blueRingGeometry = new THREE.CylinderGeometry(4, 4, blueRingHeight, 32);
const blueRingMesh = new THREE.Mesh(blueRingGeometry, blueMaterial);
blueRingMesh.position.y = towerHeight + blueRingHeight / 2;
scene.add(blueRingMesh);

/*crown_gold*/
const goldTopGeometry = new THREE.CylinderGeometry(3.8, 3.8, goldTopHeight, 32);
const goldTopMesh = new THREE.Mesh(goldTopGeometry, goldMaterial);
goldTopMesh.position.y = towerHeight + blueRingHeight + goldTopHeight / 2;
scene.add(goldTopMesh);

/*crown_gaps*/
const teethRadius = 3.8;
const numTeeth = 8;
const toothGeometry = new THREE.BoxGeometry(1.5, 1.5, 0.4);

for (let i = 0; i < numTeeth; i++) {
    const angle = (i / numTeeth) * Math.PI * 2;
    const toothMesh = new THREE.Mesh(toothGeometry, goldMaterial);
    toothMesh.position.x = Math.cos(angle) * teethRadius;
    toothMesh.position.z = Math.sin(angle) * teethRadius;
    toothMesh.position.y = 7.75;
    toothMesh.rotation.y = -angle;
    scene.add(toothMesh);
}


const studGeometry = new THREE.OctahedronGeometry(0.3);
const studCount = 4;
const studRadius = 4.05;

for (let i = 0; i < studCount; i++) {
    const angle = (i / studCount) * Math.PI * 2;
    const studMesh = new THREE.Mesh(studGeometry, goldMaterial);
    studMesh.position.x = Math.cos(angle) * studRadius;
    studMesh.position.z = Math.sin(angle) * studRadius;
    studMesh.position.y = 6.5;
    scene.add(studMesh);
}

/*TEXXTTTT!!*/
const fontLoader = new FontLoader();
fontLoader.load(
    "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",
    (font) => {
        const textGeo = new TextGeometry("Congrats on 10K!!!", {
            font: font,
            size: 0.7,
            height: 0.15,
            curveSegments: 12,
        });

        textGeo.center();

        const textMat = new THREE.MeshStandardMaterial({
            color: 0xFFD700,
            metalness: 1,
            roughness: 0.2,
            emissive: 0x553300,
            emissiveIntensity: 0.7
        });

        const textMesh = new THREE.Mesh(textGeo, textMat);
        textMesh.position.set(0, 9.5, 0);

        scene.add(textMesh);
    }
);

/*SPARKLES & Confettiiii*/
const sparkGroup = new THREE.Group();
scene.add(sparkGroup);

function createSpark() {
    const geo = new THREE.SphereGeometry(0.05);
    const mat = new THREE.MeshBasicMaterial({ color: 0xFFAA33 });

    const spark = new THREE.Mesh(geo, mat);

    const angle = Math.random() * Math.PI * 2;
    const radius = 4.2;

    spark.position.set(
        Math.cos(angle) * radius,
        8.3,
        Math.sin(angle) * radius
    );

    spark.userData.velY = Math.random() * 0.02 + 0.02;

    sparkGroup.add(spark);
}

for (let i = 0; i < 40; i++) createSpark();

const confettiGroup = new THREE.Group();
scene.add(confettiGroup);

function createConfettiPiece() {
    const geo = new THREE.BoxGeometry(0.08, 0.18, 0.02);
    const mat = new THREE.MeshBasicMaterial({
        color: new THREE.Color(Math.random(), Math.random(), Math.random())
    });

    const confetti = new THREE.Mesh(geo, mat);
    confetti.position.set(
        (Math.random() - 0.5) * 10,
        12,
        (Math.random() - 0.5) * 10
    );

    confetti.rotationSpeed = Math.random() * 0.02;
    confetti.fallSpeed = Math.random() * 0.05 + 0.02;

    confettiGroup.add(confetti);
}

for (let i = 0; i < 120; i++) createConfettiPiece();

scene.add(new THREE.AmbientLight(0xffffff, 0.8));

const sun = new THREE.DirectionalLight(0xffffff, 2);
sun.position.set(5, 15, 7);
scene.add(sun);

/*animations*/
function animate() {
    requestAnimationFrame(animate);

    // Sparkler moving
    sparkGroup.children.forEach(s => {
        s.position.y += s.userData.velY;
        if (s.position.y > 9) s.position.y = 8.1;
    });

    // Confetti moving
    confettiGroup.children.forEach(c => {
        c.rotation.x += c.rotationSpeed;
        c.rotation.y += c.rotationSpeed;
        c.position.y -= c.fallSpeed;
        if (c.position.y < -1) c.position.y = 12;
    });

    controls.update();
    renderer.render(scene, camera);
}

animate();

/*resize*/
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.fov = window.innerWidth < 600 ? 85 : 75;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
